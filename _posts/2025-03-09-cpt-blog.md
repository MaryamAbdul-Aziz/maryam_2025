---  
toc: true  
layout: post  
title: CB CPT Blog  
type: tangibles  
courses: { compsci: {week: 24} }  
---  

Required code:
- Input  
- List  
- Procedure  
- Algorithm  
  - Sequencing  
  - Selection  
  - Iteration  
- Output

```html  
<style>  
    /*expand button code*/  
    #book-list-content.collapsed .book {  
    display: none;  
    }

    #book-list-content.collapsed .book:nth-child(-n+3) {  
        display: block;  
    }

    #book-list-content {  
        overflow: hidden;  
        transition: max-height 0.5s ease;  
    }

    #book-list-content.collapsed {  
        max-height: 680px;   
    }

    #toggle-books {  
        display: block;  
        margin: 20px auto;  
        padding: 10px 20px;  
        background-color: #a57e5a;  
        color: white;  
        border: 1px solid #500A0A;  
        border-radius: 4px;  
        cursor: pointer;  
    }

    #toggle-books:hover {  
        background-color: #500A0A;  
        transition: 0.3s;  
    }  
</style>

<div class="container">  
<h1>Suggest your favorite books here!</h1>  
<form id="book-form">  
    <div>  
        <h2>Book Title</h2>  
        <label for="title">Title</label>  
        <input type="text" id="title" name="title" placeholder="Enter book title" required>  
        <h2>Author</h2>  
        <label for="author">Author</label>  
        <input type="text" id="author" name="author" placeholder="Enter author's name" required>  
        <h2>Genre</h2>  
        <label for="genre">Genre</label>  
        <select id="genre" name="genre" required>  
            <option value="">Select Genre</option>  
            <option value="Classics">Classics</option>  
            <option value="Fantasy">Fantasy</option>  
            <option value="Nonfiction">Nonfiction</option>  
            <option value="Historical Fiction">Historical Fiction</option>  
            <option value="Suspense/Thriller">Suspense/Thriller</option>  
            <option value="Romance">Romance</option>  
            <option value="Dystopian">Dystopian</option>  
            <option value="Mystery">Mystery</option>  
        </select>  
        <h2>Description</h2>  
        <label for="description">Description</label>  
        <textarea id="description" name="description" rows="5" placeholder="Enter a brief description" required></textarea>  
        <h2>Cover Image</h2>  
        <label for="cover_url">Cover Image URL</label>  
        <input type="url" id="cover_url" name="cover_url" placeholder="Enter image URL" required>  
        <button type="submit">Add Book</button>  
        <button type="reset" class="start_over">Start Over</button>  
    </div>  
</form>  
</div>

<div id="book-list" class="container2">  
    <h1>Your Suggested Books</h1><br>  
    <label for="sort-books">Sort Books:</label>  
    <select id="sort-books">  
        <option value="none">No Sort (Oldest > Newest)</option>  
        <option value="alphabetical">Alphabetically</option>  
    </select>  
    <br><br>  
    <div id="accepted-books-container">  
    <h2>Accepted Books:</h2>  
    <p id="accepted-books-list" style="color: #a57e5a;">None yet.</p></div>  
    <div id="rejected-books-container">  
    <h3>Rejected Books:</h3>  
    <p id="rejected-books-list" style="color: #a57e5a;">None yet.</p></div><br>  
    <div id="book-list-content" class="collapsed">  
        <p style="color: #a57e5a">No books added yet. Fill out the form above to start adding your favorite books!</p>  
    </div>  
    <button id="toggle-books">Show More</button>  
</div>

<script type="module">  
    import { pythonURI, fetchOptions } from '{{ site.baseurl }}/assets/js/api/config.js';

    const toggleButton = document.getElementById('toggle-books');  
    const bookList = document.getElementById('book-list-content');

    toggleButton.addEventListener('click', () => {  
        bookList.classList.toggle('collapsed');  
        bookList.classList.toggle('expanded');  
          
        toggleButton.textContent =   
            bookList.classList.contains('collapsed') ? 'Show More' : 'Show Less';  
    });

    document.getElementById('book-form').addEventListener('submit', async function(event) {  
        event.preventDefault();

        const title = document.getElementById('title').value;  
        const author = document.getElementById('author').value;  
        const genre = document.getElementById('genre').value;  
        const description = document.getElementById('description').value;  
        const cover_url = document.getElementById('cover_url').value;

        const bookData = {  
            title: title,  
            author: author,  
            genre: genre,  
            description: description,  
            cover_url: cover_url  
        };  
          
        try {  
            const response = await fetch(`${pythonURI}/api/suggest`, {  // Use /api/suggest endpoint  
                ...fetchOptions,  
                method: 'POST',  
                headers: {  
                    'Content-Type': 'application/json'  
                },  
                body: JSON.stringify(bookData)  
            });

            if (!response.ok) {  
                throw new Error('Failed to add book to suggestions: ' + response.statusText);  
            }

            const result = await response.json();  
            console.log("Book added to suggestions successfully")  
            alert('Book added successfully!');  
            document.getElementById('book-form').reset();  
            fetchBooks();  // Refresh book list  
        } catch (error) {  
            console.error('Error adding book to suggestions:', error);  
            alert('Error adding book to suggestions: ' + error.message);  
        }  
    });

    async function fetchRandomBook() {  
        try {  
            const response = await fetch(`${pythonURI}/api/suggest/random`);  // Use /api/suggest/random for GET  
            if (!response.ok) {  
                throw new Error('Failed to fetch random book: ' + response.statusText);  
            }  
            const book = await response.json();  
        } catch (error) {  
            console.error('Error fetching random book:', error);  
        }  
    }

    fetchRandomBook();

    async function deleteBook(title) {  
        if (confirm(`Are you sure you want to delete "${title}"?`)) {  
            try {  
                const response = await fetch(`${pythonURI}/api/suggest`, {  
                    ...fetchOptions,  
                    method: 'DELETE',  
                    headers: {  
                        'Content-Type': 'application/json'  
                    },  
                    body: JSON.stringify({ title }) // Pass title as an object  
                });

                if (!response.ok) {  
                    throw new Error('Failed to delete book: ' + response.statusText);  
                }

                console.log("Book deleted successfully");  
                alert('Book deleted successfully!');  
                fetchBooks(); // Refresh the book list  
            } catch (error) {  
                console.error('Error deleting book:', error);  
                alert('Error deleting book: ' + error.message);  
            }  
        } else {  
            alert("Deletion canceled");  
        }  
    }

    async function updateBook(title) {  
    const bookContainer = Array.from(document.querySelectorAll('.book'))  
        .find(book => book.querySelector('h3').innerText === title);

    if (!bookContainer) {  
        alert('Book not found for update.');  
        return;  
    }

    const currentTitle = bookContainer.querySelector('h3').innerText;  
    const currentAuthor = bookContainer.querySelector('p:nth-child(2)').innerText.split(': ')[1];  
    const descriptionElement = Array.from(bookContainer.querySelectorAll('p'))  
        .find(p => p.innerText.startsWith('Description:'));  
    const currentDescription = descriptionElement ? descriptionElement.innerText.replace('Description: ', '') : '';  
    const currentGenre = bookContainer.dataset.genre || '';  
    const currentCoverUrl = bookContainer.querySelector('img').src;

    // Replace static fields with editable inputs  
    bookContainer.innerHTML = `  
        <input type="text" id="edit-title" value="${currentTitle}" placeholder="Title">  
        <input type="text" id="edit-author" value="${currentAuthor}" placeholder="Author">  
        <select id="edit-genre">  
            <option value="Classics" ${currentGenre === 'Classics' ? 'selected' : ''}>Classics</option>  
            <option value="Fantasy" ${currentGenre === 'Fantasy' ? 'selected' : ''}>Fantasy</option>  
            <option value="Nonfiction" ${currentGenre === 'Nonfiction' ? 'selected' : ''}>Nonfiction</option>  
            <option value="Historical Fiction" ${currentGenre === 'Historical Fiction' ? 'selected' : ''}>Historical Fiction</option>  
            <option value="Suspense/Thriller" ${currentGenre === 'Suspense/Thriller' ? 'selected' : ''}>Suspense/Thriller</option>  
            <option value="Romance" ${currentGenre === 'Romance' ? 'selected' : ''}>Romance</option>  
            <option value="Dystopian" ${currentGenre === 'Dystopian' ? 'selected' : ''}>Dystopian</option>  
            <option value="Mystery" ${currentGenre === 'Mystery' ? 'selected' : ''}>Mystery</option>  
        </select>  
        <textarea id="edit-description" placeholder="Description">${currentDescription}</textarea>  
        <input type="text" id="edit-cover-url" value="${currentCoverUrl}" placeholder="Cover URL">  
        <button id="save-update">OK</button>  
        <button id="cancel-update">Cancel</button>  
    `;

    // Handle Cancel Button  
    document.getElementById('cancel-update').addEventListener('click', () => {  
        fetchBooks(); // Reload the book list to cancel editing  
    });

    document.getElementById('save-update').addEventListener('click', async () => {  
        const updatedTitle = document.getElementById('edit-title').value;  
        const updatedAuthor = document.getElementById('edit-author').value;  
        const updatedGenre = document.getElementById('edit-genre').value;  
        const updatedDescription = document.getElementById('edit-description').value;  
        const updatedCoverUrl = document.getElementById('edit-cover-url').value;

        const updatedBookData = {  
            title: title,  
            author: updatedAuthor,  
            genre: updatedGenre,  
            description: updatedDescription,  
            cover_url: updatedCoverUrl  
        };

        try {  
            const response = await fetch(`${pythonURI}/api/suggest`, {  
                ...fetchOptions,  
                method: 'PUT',  
                headers: {  
                    'Content-Type': 'application/json'  
                },  
                body: JSON.stringify(updatedBookData)  
            });

            if (!response.ok) {  
                throw new Error('Failed to update book: ' + response.statusText);  
            }

            console.log('Book updated successfully');  
            alert('Book updated successfully!');  
            fetchBooks(); // Refresh the book list  
        } catch (error) {  
            console.error('Error updating book:', error);  
            alert('Error updating book: ' + error.message);  
        }  
    });  
}  
      
    let acceptedBooks = ""; // Variable to store accepted books list

    function updateAcceptedBooksList() {  
        const acceptedBooksListElement = document.getElementById("accepted-books-list");  
        acceptedBooksListElement.textContent = acceptedBooks.trim() ? acceptedBooks : "None yet.";  
    }

    async function acceptBook(title) {  
    const bookContainer = Array.from(document.querySelectorAll('.book'))  
        .find(book => book.querySelector('h3').innerText === title);

    if (!bookContainer) {  
        alert('Book not found for acceptance.');  
        return;  
    }

    const author = bookContainer.querySelector('p:nth-child(2)').innerText.split(': ')[1];  
    const genre = bookContainer.querySelector('p:nth-child(3)').innerText.split(': ')[1];  
    const description = bookContainer.querySelector('p:nth-child(4)').innerText.replace('Description: ', '');  
    const cover_url = bookContainer.querySelector('img').src;

    const bookData = {  
        title: title,  
        author: author,  
        genre: genre,  
        description: description,  
        cover_url: cover_url  
    };

    try {  
        const response = await fetch(`${pythonURI}/api/suggest/accept`, {   
            ...fetchOptions,  
            method: 'POST',  
            headers: {  
                'Content-Type': 'application/json'  
            },  
            body: JSON.stringify(bookData)  
        });

        const response2 = await fetch(`${pythonURI}/api/suggest`, {  
            ...fetchOptions,  
            method: 'DELETE',  
            headers: {  
                'Content-Type': 'application/json'  
            },  
            body: JSON.stringify({ title })   
        });

        if (!response2.ok) {  
            throw new Error('Failed to accept book: ' + response2.statusText);  
        }

        acceptedBooks += (acceptedBooks ? ", " : "") + title;  
        updateAcceptedBooksList(); // Update display  
          
        console.log("Book accepted successfully");  
        alert('Book accepted successfully!');  
        console.log("Book removed from suggestions successfully");  
        fetchBooks();  // Refresh book list  
    } catch (error) {  
        console.error('Error accepting book:', error);  
        alert('Error accepting book: ' + error.message);  
    }  
}   

let rejectedBooks = ""; // Variable to store accepted books list

    function updateRejectedBooksList() {  
        const rejectedBooksListElement = document.getElementById("rejected-books-list");  
        rejectedBooksListElement.textContent = rejectedBooks.trim() ? rejectedBooks : "None yet.";  
    }

async function rejectBook(title) {  
    if (confirm(`Are you sure you want to reject "${title}"?`)) {  
        try {  
            const response = await fetch(`${pythonURI}/api/suggest`, {  
                ...fetchOptions,  
                method: 'DELETE',  
                headers: {  
                    'Content-Type': 'application/json'  
                },  
                body: JSON.stringify({ title }) // Pass title as an object  
            });

            if (!response.ok) {  
                throw new Error('Failed to reject book: ' + response.statusText);  
            }

            console.log("Book rejected successfully");  
            alert('Book rejected successfully!');  
            rejectedBooks += (rejectedBooks ? ", " : "") + title;  
            updateRejectedBooksList();  
            fetchBooks();  
        } catch (error) {  
            console.error('Error rejecting book:', error);  
            alert('Error rejecting book: ' + error.message);  
        }  
    } else {  
        alert("Rejection canceled");  
    }  
}

document.getElementById('sort-books').addEventListener('change', fetchBooks);

    // create list at bottom  
    async function fetchBooks() {  
        try {  
            const response = await fetch(new URL(`${pythonURI}/api/suggest/book`), fetchOptions); // Fetch all suggested books  
            if (!response.ok) {  
                throw new Error('Failed to fetch books: ' + response.statusText);  
            }

        const books = await response.json();

        const sortOption = document.getElementById('sort-books').value;  
        if (sortOption === "alphabetical") {  
            books.sort((a, b) => a.title.localeCompare(b.title));  
        }

        const bookList = document.getElementById('book-list-content');  
        if (books.length === 0) {  
            bookList.innerHTML = '<p style="color: #000000">No books added yet. Fill out the form above to start adding your favorite books!</p>';  
            return;  
        }

        // Render books  
    bookList.innerHTML = books  
    .map(  
        book => `  
        <div class="book">  
            <h3>${book.title}</h3>  
            <p><strong>Author:</strong> ${book.author}</p>  
            <p><strong>Genre:</strong> ${book.genre}</p>  
            <p><strong>Description:</strong> ${book.description}</p>  
            <img src="${book.cover_url}" alt="Cover image of ${book.title}">  
            <div class="book-options">  
                <button class="updateButton" data-title="${book.title}">Update</button>  
                <button class="deleteButton" data-title="${book.title}">Delete</button>  
                <button class="acceptButton" data-title="${book.title}">Accept</button>  
                <button class="rejectButton" data-title="${book.title}">Reject</button>  
            </div>  
        </div>  
    `  
    )  
    .join('');  
          
        document.querySelectorAll('.updateButton').forEach(button => {  
            button.addEventListener('click', (event) => {  
                const title = event.target.dataset.title; // Get the title from data attribute  
                updateBook(title);  
            });  
        });  
        document.querySelectorAll('.deleteButton').forEach(button => {  
            button.addEventListener('click', (event) => {  
                const title = event.target.dataset.title;   
                deleteBook(title);  
            });  
        });  
        document.querySelectorAll('.acceptButton').forEach(button => {  
            button.addEventListener('click', (event) => {  
                const title = event.target.dataset.title; // Get the title from data attribute  
                acceptBook(title);  
            });  
        });  
        document.querySelectorAll('.rejectButton').forEach(button => {  
            button.addEventListener('click', (event) => {  
                const title = event.target.dataset.title; // Get the title from data attribute  
                rejectBook(title);  
            });  
        });

    } catch (error) {  
        console.error('Error fetching books:', error);  
    }  
}

document.addEventListener('DOMContentLoaded', () => {  
    fetchBooks();  
});

</script>  
```

```python  
from flask import Blueprint, request, jsonify, g  
from flask_restful import Api  
from flask_login import current_user, login_required  
from api.jwt_authorize import token_required  
from model.librarydb import Book  
from model.suggest import SuggestedBook  
from __init__ import db

# Define Blueprint and Api  
suggest_api = Blueprint('suggest_api', __name__, url_prefix='/api/suggest')  
api = Api(suggest_api)

# Endpoint to add suggested books (Create)  
@suggest_api.route('', methods=['POST'])    
def add_book():  
    if not request.json or 'title' not in request.json:  
        return jsonify({'error': 'Title is required to create the book'}), 400  
    data = request.json

    title = data.get('title')  
    author = data.get('author')  
    genre = data.get('genre')  
    description = data.get('description')  
    cover_url = data.get('cover_url')

    try:  
        # Create and add the suggested book  
        suggested_book = SuggestedBook(title=title, author=author, genre=genre, description=description, cover_url=cover_url)  
        suggested_book.create()  
        return jsonify({'message': 'Book added successfully to suggestions'}), 201  
    except Exception as e:  
        return jsonify({'error': 'Failed to add book', 'message': str(e)}), 500

# Add multiple suggested books (Create)  
@suggest_api.route('/bulk', methods=['POST'])  
def add_books_bulk():  
    data = request.json

    if not isinstance(data, list):  
        return jsonify({'error': 'Expected a list of books'}), 400

    results = []

    for book_data in data:  
        title = book_data.get('title')  
        author = book_data.get('author')  
        genre = book_data.get('genre')  
        description = book_data.get('description')  
        cover_url = book_data.get('cover_url')

        try:  
            # Create and add the suggested book  
            suggested_book = SuggestedBook(title=title, author=author, genre=genre, description=description, cover_url=cover_url)  
            suggested_book.create()  
            results.append({'message': f'Book {title} added successfully to suggestions', 'title': title})  
        except Exception as e:  
            results.append({'error': f'Failed to add book {title}', 'message': str(e), 'title': title})

    return jsonify(results), 201

# Endpoint to fetch a random suggested book (Read)  
@suggest_api.route('/book', methods=['GET'])  
def get_suggestion():  
    try:  
        # Query all suggested books  
        books = SuggestedBook.query.all()

        # Convert the list of book objects to a list of dictionaries  
        books_data = [  
            {  
                'title': book.title,  
                'author': book.author,  
                'genre': book.genre,  
                'description': book.description,  
                'cover_url': book.cover_url  
            }  
            for book in books  
        ]

        return jsonify(books_data), 200  
    except Exception as e:  
        return jsonify({'error': 'Failed to fetch books', 'message': str(e)}), 500

# Endpoint to fetch a random suggested book (Read)  
@suggest_api.route('/random', methods=['GET'])  
def random_book():  
    book = SuggestedBook.get_random_suggested_book()  
    if book:  
        return jsonify({  
            'title': book.title,  
            'author': book.author,  
            'genre': book.genre,  
            'description': book.description,  
            'cover_url': book.cover_url  
        })  
    else:  
        return jsonify({'error': 'No books found'}), 404  
      
# Endpoint to update existing suggested book (Update)  
@suggest_api.route('', methods=['PUT'])  
def update_book():  
    data = request.json

    title = data.get('title')  
    if not title:  
        return jsonify({'error': 'Title is required to update the book'}), 400

    try:  
        # Fetch the existing book by title  
        suggested_book = SuggestedBook.query.filter_by(title=title).first()  
        if not suggested_book:  
            return jsonify({'error': 'Book not found'}), 404

        # Update the book details  
        suggested_book.title = data.get('title', suggested_book.title)  
        suggested_book.author = data.get('author', suggested_book.author)  
        suggested_book.genre = data.get('genre', suggested_book.genre)  
        suggested_book.description = data.get('description', suggested_book.description)  
        suggested_book.cover_url = data.get('cover_url', suggested_book.cover_url)

        suggested_book.update()   
        return jsonify({'message': 'Book updated successfully'}), 200  
    except Exception as e:  
        return jsonify({'error': 'Failed to update book', 'message': str(e)}), 500

# Endpoint to delete  suggested book (Delete)  
@suggest_api.route('', methods=['DELETE'])  
def delete_book():  
    data = request.json  
      
    title = data.get('title')  
    if not title:  
        return jsonify({'error': 'Title is required to delete the book'}), 400

    try:  
        suggested_book = SuggestedBook.query.filter_by(title=title).first()  
          
        if not suggested_book:  
            return jsonify({'error': 'Book not found'}), 404  
          
        db.session.delete(suggested_book)  
        db.session.commit()  
          
        return jsonify({'message': 'Book deleted successfully'}), 200  
    except Exception as e:  
        return jsonify({'error': 'Failed to delete book', 'message': str(e)}), 500

@suggest_api.route('/accept', methods=['POST'])  
@token_required()  
def accept_suggestion():  
    data = request.json

    title = data.get('title')  
    author = data.get('author')  
    genre = data.get('genre')  
    description = data.get('description')  
    cover_url = data.get('cover_url')  
      
    if g.current_user.role != 'Admin':  
        return jsonify({'error': 'Unauthorized'}), 403  
      
    if not request.json or 'title' not in request.json:  
        return jsonify({'error': 'Title is required to add the book'}), 400

    try:  
        # Create and add the suggested book  
        accepted_book = Book(title=title, author=author, genre=genre, description=description, cover_url=cover_url)  
        accepted_book.create()  
        return jsonify({'message': 'Book added successfully'}), 201  
    except Exception as e:  
        return jsonify({'error': 'Failed to add book', 'message': str(e)}), 500  
      
# unused reject code (appends REJECTED: to the title)  
@suggest_api.route('/reject', methods=['POST'])  
@token_required()  
def reject_suggestion():  
    data = request.json  
    title = data.get('title')

    if g.current_user.role != 'Admin':  
        return jsonify({'error': 'Unauthorized'}), 403

    if not title:  
        return jsonify({'error': 'Title is required to reject the book'}), 400

    try:  
        book = SuggestedBook.query.filter_by(title=title).first()  
        if not book:  
            return jsonify({'error': 'Book not found'}), 404

        # Prepend "Rejected: " only if it's not already there  
        if not book.title.startswith("REJECTED: "):  
            book.title = f"REJECTED: {book.title}"  
            book.update()

        return jsonify({'message': 'Book rejected successfully'}), 200  
    except Exception as e:  
        return jsonify({'error': 'Failed to reject book', 'message': str(e)}), 500  
```

```python  
from __init__ import db, app  
from sqlalchemy import Column, Integer, String, Text  
from sqlalchemy.exc import IntegrityError  
from model.librarydb import Book  
import random

class SuggestedBook(db.Model):  
    __tablename__ = 'suggestions'  
    id = db.Column(db.Integer, primary_key=True)  
    title = db.Column(db.String, unique=True, nullable=False)  
    author = db.Column(db.String, nullable=False)  
    genre = db.Column(db.String, nullable=False)  
    description = db.Column(db.Text, nullable=True)  
    cover_url = db.Column(db.String, nullable=True)

    def __init__(self, title, author, genre, description, cover_url):  
        self.title = title  
        self.author = author  
        self.genre = genre  
        self.description = description  
        self.cover_url = cover_url

    def add_suggested_book(title, author, genre, description, cover_url):  
        new_suggested_book = SuggestedBook(  
            title=title,  
            author=author,  
            genre=genre,  
            description=description,  
            cover_url=cover_url  
        )

        new_book = Book(  
            title=title,  
            author=author,  
            genre=genre,  
            description=description,  
            cover_url=cover_url  
        )

        try:  
            db.session.add(new_suggested_book)  
            db.session.add(new_book)  
            db.session.commit()  
        except Exception as e:  
            db.session.rollback()  
            raise e

    def __repr__(self):  
        return f"<SuggestedBook {self.title}>"  
      
    def get_random_suggested_book():  
        try:  
            suggested_books_query = SuggestedBook.query.all()  
            return random.choice(suggested_books_query) if suggested_books_query else None  
        except Exception as e:  
            print(f"Error while fetching random book: {e}")  
            return None  
      
    def create(self):  
        db.session.add(self)  
        db.session.commit()  
          
    def read(self):  
        """  
        Retrieve the vote data as a dictionary.

        Returns:  
            dict: Dictionary with vote information.  
        """  
        return {  
            "id": self.id,  
            "title": self.title,  
            "author": self.author,  
            "genre": self.genre,  
            "description": self.description,  
            "cover_url": self.cover_url  
        }  
          
    def update(self):  
        """  
        The update method commits the transaction to the database.  
          
        Uses:  
            The db ORM method to commit the transaction.  
          
        Raises:  
            Exception: An error occurred when updating the object in the database.  
        """  
        try:  
            db.session.commit()  
        except Exception as e:  
            db.session.rollback()  
            raise e  
      
    def delete(self):  
        """  
        The delete method removes the object from the database and commits the transaction.  
          
        Uses:  
            The db ORM methods to delete and commit the transaction.  
          
        Raises:  
            Exception: An error occurred when deleting the object from the database.  
        """      
        try:  
            db.session.delete(self)  
            db.session.commit()  
        except Exception as e:  
            db.session.rollback()  
        raise Exception(f"An error occurred while deleting the object: {str(e)}") from e  
      
    @staticmethod  
    def restore(data):  
        """  
        Restores a list of suggested books from the provided data. If a book with the same  
        title already exists, it updates it; otherwise, it creates a new one.

        Args:  
            data (list): A list of dictionaries containing suggested book data.

        Returns:  
            dict: A dictionary of restored suggested books (book id as keys).  
        """  
        restored_books = {}

        for book_data in data:  
            # Remove 'id' from the data if it exists (because id will be auto-generated)  
            _ = book_data.pop('id', None)

            # Check if the book already exists based on title  
            existing_book = SuggestedBook.query.filter_by(title=book_data.get("title")).first()  
            if existing_book:  
                # Update the existing book with new data  
                existing_book.title = book_data.get('title', existing_book.title)  
                existing_book.author = book_data.get('author', existing_book.author)  
                existing_book.genre = book_data.get('genre', existing_book.genre)  
                existing_book.description = book_data.get('description', existing_book.description)  
                existing_book.cover_url = book_data.get('cover_url', existing_book.cover_url)  
                db.session.commit()  
                restored_books[existing_book.id] = existing_book  
            else:  
                # Create a new suggested book  
                new_book = SuggestedBook(**book_data)  
                new_book.create()  
                restored_books[new_book.id] = new_book

        return restored_books

def initSuggest():  
    with app.app_context():  
        db.create_all()  
          
    # tester data  
    suggest_data = [  
        SuggestedBook(title="The Raven Boys", author="Maggie Stiefvater", genre="Fantasy", description="A young adult fantasy novel about a girl from a family of clairvoyants, the boys she befriends, and how their lives are intertwined along their journey to wake a slumbering king.", cover_url="https://m.media-amazon.com/images/I/71s5v4HfFjL._AC_UF1000,1000_QL80_.jpg"),  
        SuggestedBook(title="Catch-22", author="Joseph Heller", genre="Classics", description="The work centres on Captain John Yossarian, an American bombardier stationed on a Mediterranean island during World War II, and chronicles his desperate attempts to stay alive.", cover_url="https://d28hgpri8am2if.cloudfront.net/book_images/cvr9781451621174_9781451621174_hr.jpg"),  
        SuggestedBook(title="A Midsummer Night's Dream", author="William Shakespeare", genre="Classics", description="Four Athenians run away to the forest only to have Puck the fairy make both of the boys fall in love with the same girl.", cover_url="https://m.media-amazon.com/images/I/71plvG7VRiL._AC_UF1000,1000_QL80_.jpg"),  
        SuggestedBook(title="Never Let Me Go", author="Kazuo Ishiguro", genre="Mystery", description="Never Let Me Go follows students' lives at an elite boarding school. The story explores themes of friendship, memories, and what it means to be human, gradually revealing deeper mysteries about the nature of their world.", cover_url="https://images.penguinrandomhouse.com/cover/9781400078776"),          
        SuggestedBook(title="A Deadly Education", author="Naomi Novik", genre="Fantasy", description="A Deadly Education is a 2020 fantasy novel written by American author Naomi Novik following Galadriel "El" Higgins, a half-Welsh, half-Indian sorceress, who must survive to graduation while controlling her destructive abilities at a school of magic very loosely inspired by the legend of the Scholomance.", cover_url="https://m.media-amazon.com/images/I/81j2VmcrS-L._AC_UF1000,1000_QL80_.jpg"),  
        SuggestedBook(title="House of Leaves", author="Mark Z. Danielewski", genre="Suspense/Thriller", description="The House of Leaves synopsis details a story about a young man who finds a manuscript about a family's documentary, The Navidson Record, which details their experiences with a strange house.", cover_url="https://images.penguinrandomhouse.com/cover/9780375420528"),  
        SuggestedBook(title="The Cruel Prince", author="Holly Black", genre="Fantasy", description="Jude was seven years old when her parents were murdered and she and her two sisters were stolen away to live in the treacherous High Court of Faerie. Ten years later, Jude wants nothing more than to belong there, despite her mortality. But many of the fey despise humans.", cover_url="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRFRlLnHzV7FMzb6ouRYUgQmKd34ss7NZTbcw&s"),      
        SuggestedBook(title="The Very Hungry Caterpillar", author="Eric Carle", genre="Classics", description="The plot follows a very hungry caterpillar that consumes a variety of foods before pupating and becoming a butterfly", cover_url="https://upload.wikimedia.org/wikipedia/en/b/b5/HungryCaterpillar.JPG"),      
    ]  
    

    for suggestion in suggest_data:  
            try:  
                if not Book.query.filter_by(title=suggestion.title).first() and not SuggestedBook.query.filter_by(title=suggestion.title).first():  
                    db.session.add(suggestion)  
                    db.session.commit()  
            except IntegrityError:  
                # Fails with bad or duplicate data  
                db.session.rollback()  
```
